(function(e, a) { for(var i in a) e[i] = a[i]; }(exports, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const coc_nvim_1 = __webpack_require__(1);
const io_1 = __webpack_require__(2);
const db_1 = __importDefault(__webpack_require__(5));
const bookmark_1 = __importDefault(__webpack_require__(7));
const commands_1 = __importDefault(__webpack_require__(8));
function activate(context) {
    return __awaiter(this, void 0, void 0, function* () {
        const config = coc_nvim_1.workspace.getConfiguration('bookmark');
        const enable = config.get('enable', true);
        if (!enable) {
            return;
        }
        const { subscriptions, storagePath } = context;
        const { nvim } = coc_nvim_1.workspace;
        const maxsize = config.get('maxsize', 5000);
        const db = new db_1.default(storagePath, 'bookmark', maxsize);
        const bookmark = new commands_1.default(nvim, db);
        const stat = yield io_1.statAsync(storagePath);
        if (!stat || !stat.isDirectory()) {
            yield io_1.mkdirAsync(storagePath);
        }
        const sign = config.get('sign', 'âš‘');
        const signHi = config.get('signHi', 'Identifier');
        if (signHi) {
            yield nvim.command(`hi link BookmarkTextDefHi ${signHi}`);
        }
        else {
            yield nvim.command('hi link BookmarkTextDefHi Identifier');
        }
        nvim.command(`sign define BookMark text=${sign} texthl=BookmarkTextDefHi`, true);
        coc_nvim_1.workspace.onDidOpenTextDocument(() => __awaiter(this, void 0, void 0, function* () {
            yield bookmark.updateSign();
        }), null, subscriptions);
        coc_nvim_1.workspace.onDidChangeTextDocument(() => __awaiter(this, void 0, void 0, function* () {
            yield bookmark.updateSign();
        }), null, subscriptions);
        coc_nvim_1.events.on('CursorHold', () => __awaiter(this, void 0, void 0, function* () {
            yield bookmark.updateSign();
        }), null, subscriptions);
        coc_nvim_1.events.on('BufEnter', () => __awaiter(this, void 0, void 0, function* () {
            yield bookmark.updateSign();
        }), null, subscriptions);
        subscriptions.push(coc_nvim_1.workspace.registerKeymap(['n'], 'bookmark-toggle', () => __awaiter(this, void 0, void 0, function* () { return yield bookmark.toggle(); }), { sync: false }));
        subscriptions.push(coc_nvim_1.workspace.registerKeymap(['n'], 'bookmark-annotate', () => __awaiter(this, void 0, void 0, function* () { return yield bookmark.annotate(); }), { sync: false }));
        subscriptions.push(coc_nvim_1.workspace.registerKeymap(['n'], 'bookmark-next', () => __awaiter(this, void 0, void 0, function* () { return yield bookmark.find('next'); }), { sync: false }));
        subscriptions.push(coc_nvim_1.workspace.registerKeymap(['n'], 'bookmark-prev', () => __awaiter(this, void 0, void 0, function* () { return yield bookmark.find('prev'); }), { sync: false }));
        subscriptions.push(coc_nvim_1.commands.registerCommand('bookmark.toggle', () => __awaiter(this, void 0, void 0, function* () { return yield bookmark.toggle(); })));
        subscriptions.push(coc_nvim_1.commands.registerCommand('bookmark.annotate', () => __awaiter(this, void 0, void 0, function* () { return yield bookmark.annotate(); })));
        subscriptions.push(coc_nvim_1.commands.registerCommand('bookmark.prev', () => __awaiter(this, void 0, void 0, function* () { return yield bookmark.find('prev'); })));
        subscriptions.push(coc_nvim_1.commands.registerCommand('bookmark.next', () => __awaiter(this, void 0, void 0, function* () { return yield bookmark.find('next'); })));
        subscriptions.push(coc_nvim_1.listManager.registerList(new bookmark_1.default(nvim, db)));
    });
}
exports.activate = activate;


/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("coc.nvim");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(__webpack_require__(3));
const util_1 = __importDefault(__webpack_require__(4));
function statAsync(filepath) {
    return __awaiter(this, void 0, void 0, function* () {
        let stat = null;
        try {
            stat = yield util_1.default.promisify(fs_1.default.stat)(filepath);
        }
        catch (e) {
            // noop
        }
        return stat;
    });
}
exports.statAsync = statAsync;
function writeFile(fullpath, content) {
    return __awaiter(this, void 0, void 0, function* () {
        yield util_1.default.promisify(fs_1.default.writeFile)(fullpath, content, 'utf8');
    });
}
exports.writeFile = writeFile;
function readFile(fullpath, encoding = 'utf8') {
    return new Promise((resolve, reject) => {
        fs_1.default.readFile(fullpath, encoding, (err, content) => {
            if (err)
                reject(err);
            resolve(content);
        });
    });
}
exports.readFile = readFile;
function mkdirAsync(filepath) {
    return new Promise((resolve, reject) => {
        fs_1.default.mkdir(filepath, err => {
            if (err)
                return reject(err);
            resolve();
        });
    });
}
exports.mkdirAsync = mkdirAsync;
function group(array, size) {
    let len = array.length;
    let res = [];
    for (let i = 0; i < Math.ceil(len / size); i++) {
        res.push(array.slice(i * size, (i + 1) * size));
    }
    return res;
}
exports.group = group;


/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("util");

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const io_1 = __webpack_require__(2);
const path_1 = __importDefault(__webpack_require__(6));
class DB {
    constructor(directory, name, maxsize) {
        this.maxsize = maxsize;
        this.file = path_1.default.join(directory, `${name}.json`);
    }
    load() {
        return __awaiter(this, void 0, void 0, function* () {
            const stat = yield io_1.statAsync(this.file);
            if (!stat || !stat.isFile())
                return new Map();
            const content = yield io_1.readFile(this.file);
            const map = new Map(JSON.parse(content));
            for (let p of map.keys()) {
                const s = yield io_1.statAsync(p);
                if (!s || !s.isFile()) {
                    map.delete(p);
                }
            }
            return map;
        });
    }
    add(data, path) {
        return __awaiter(this, void 0, void 0, function* () {
            let items = yield this.load();
            if (items.size == this.maxsize) {
                items.delete([...items][0][0]); // TODO
            }
            const bookmarks = items.get(path) || [];
            bookmarks.push(data);
            items.set(path, bookmarks);
            yield io_1.writeFile(this.file, JSON.stringify([...items], null, 2));
        });
    }
    delete(path, lnum) {
        return __awaiter(this, void 0, void 0, function* () {
            const items = yield this.load();
            let bookmarks = items.get(path);
            if (bookmarks) {
                bookmarks = bookmarks.filter(b => b.lnum != lnum);
                if (bookmarks.length === 0) { // no bookmarks in this path
                    items.delete(path);
                }
                else {
                    items.set(path, bookmarks);
                }
                yield io_1.writeFile(this.file, JSON.stringify([...items], null, 2));
            }
        });
    }
}
exports.default = DB;


/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const coc_nvim_1 = __webpack_require__(1);
class BookmarkList extends coc_nvim_1.BasicList {
    constructor(nvim, db) {
        super(nvim);
        this.nvim = nvim;
        this.db = db;
        this.name = 'bookmark';
        this.description = 'bookmark';
        this.defaultAction = 'open';
        this.actions = [];
        this.addLocationActions();
        this.addAction('preview', (item, context) => __awaiter(this, void 0, void 0, function* () {
            const { bookmark } = item.data;
            const { line, filetype } = bookmark;
            const lines = [line];
            yield this.preview({
                bufname: 'bookmark',
                sketch: true,
                filetype,
                lines,
            }, context);
        }), { persist: true, reload: true });
        this.addAction('delete', (item) => __awaiter(this, void 0, void 0, function* () {
            const { bookmark, path } = item.data;
            const { lnum } = bookmark;
            yield this.db.delete(path, lnum);
        }), { persist: true, reload: true });
    }
    loadItems(_context) {
        return __awaiter(this, void 0, void 0, function* () {
            const map = yield this.db.load();
            let res = [];
            for (const [path, bookmarks] of map.entries()) {
                for (const bookmark of bookmarks) {
                    const { lnum, annotation } = bookmark;
                    res.push({
                        label: `${path.toString()} line: ${lnum}\t\t${annotation ? annotation : ''}`,
                        filterText: annotation + path,
                        data: Object.assign({}, { path, bookmark }),
                        location: coc_nvim_1.Uri.file(path).toString()
                    });
                }
            }
            return res;
        });
    }
    doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command('syntax match BookmarkFilePath /\\v^.*line: \\d+/', true);
        nvim.command('syntax match BookmarkAnnotation /\\v\\t.*$/', true);
        nvim.command('highlight default link BookmarkFilePath String', true);
        nvim.command('highlight default link BookmarkAnnotation Statement', true);
        nvim.resumeNotification().catch(_e => {
            // noop
        });
    }
}
exports.default = BookmarkList;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const coc_nvim_1 = __webpack_require__(1);
class Bookmark {
    constructor(nvim, db) {
        this.nvim = nvim;
        this.db = db;
        this.signCache = new Set();
    }
    getDocInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            const doc = yield coc_nvim_1.workspace.document;
            const lnum = yield this.nvim.call('line', ['.']);
            const line = yield this.nvim.line;
            const filetype = doc.filetype;
            const filepath = coc_nvim_1.Uri.parse(doc.uri).fsPath;
            return { lnum, line, filetype, filepath };
        });
    }
    create(annotation) {
        return __awaiter(this, void 0, void 0, function* () {
            const { lnum, line, filetype, filepath } = yield this.getDocInfo();
            const bookmark = {
                lnum,
                line,
                filetype,
                annotation
            };
            yield this.db.add(bookmark, filepath);
        });
    }
    annotate() {
        return __awaiter(this, void 0, void 0, function* () {
            const annotation = yield coc_nvim_1.workspace.requestInput('Annotation');
            if (annotation && annotation.trim()) {
                yield this.create(annotation.trim());
            }
        });
    }
    delete() {
        return __awaiter(this, void 0, void 0, function* () {
            const { lnum, filepath } = yield this.getDocInfo();
            yield this.db.delete(filepath, lnum);
        });
    }
    toggle() {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.db.load();
            const { lnum, filepath } = yield this.getDocInfo();
            const bookmarks = data.get(filepath);
            if (bookmarks) {
                if (bookmarks.filter(b => b.lnum === lnum).length !== 0) {
                    yield this.delete();
                    return;
                }
            }
            yield this.create('');
        });
    }
    find(direction) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.db.load();
            const { filepath, lnum } = yield this.getDocInfo();
            const bookmark = data.get(filepath);
            if (bookmark) {
                if (direction === 'next') {
                    for (const blnum of bookmark.map(b => b.lnum).sort()) {
                        if (blnum > lnum) {
                            yield coc_nvim_1.workspace.moveTo({
                                line: Math.max(blnum - 1, 0),
                                character: 0
                            });
                            return;
                        }
                    }
                }
                else {
                    for (const blnum of bookmark.map(b => b.lnum).sort().reverse()) {
                        if (blnum < lnum) {
                            yield coc_nvim_1.workspace.moveTo({
                                line: Math.max(blnum - 1, 0),
                                character: 0
                            });
                            return;
                        }
                    }
                }
            }
        });
    }
    updateSign() {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.db.load();
            const { filepath } = yield this.getDocInfo();
            const bookmarks = data.get(filepath);
            if (bookmarks) {
                const signLnums = bookmarks.map(b => b.lnum);
                for (const lnum of this.signCache) {
                    if (signLnums.indexOf(lnum) < 0) {
                        yield this.nvim.command(`silent! sign unplace ${lnum}`);
                        this.signCache.clear();
                    }
                }
                for (const bookmark of bookmarks) {
                    const { lnum, line } = bookmark;
                    const currLine = yield this.nvim.call('getline', [lnum]);
                    if (currLine.trim() !== line.trim()) {
                        yield this.db.delete(filepath, lnum);
                        continue;
                    }
                    const cmd = `exe ":sign place ${lnum} line=${lnum} name=BookMark file=" . expand("%:p")`;
                    this.signCache.add(lnum);
                    this.nvim.command(cmd, true);
                }
            }
            else {
                if (this.signCache.size != 0) {
                    for (const lnum of this.signCache) {
                        yield this.nvim.command(`silent! sign unplace ${lnum}`);
                        this.signCache.clear();
                    }
                }
            }
        });
    }
}
exports.default = Bookmark;


/***/ })
/******/ ])));